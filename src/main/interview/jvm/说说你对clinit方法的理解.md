#说说你对clinit方法的理解
### 说明
1. <clinit>()方法是有编译器自动收集类中的所有类变量的赋值动作和静态语句块(static{}块)中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但不能访问。 

2. <clinit>()方法与类的构造函数(即在虚拟机视角中的实例构造器<init>()方法)不同，它不需要显示地调用父类构造器，java虚拟机会保证在子类的<clinit>()方法的类型肯定是java.lang.Object

3. <clinit>()方法对于类或接口来说并不是必需的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器额可以不为这个类生成<clinit>()

4. 接口中不能使用静态语句块，但仍然有变量初始化的赋值操作，因此接口与类一样都会生成<clinit>()方法。但接口与类不同的是，执行接口的<clinit>()方法不需要先执行父接口的<clinit>()方法，因为只有父接口中定义的变量被使用时，父接口才会被初始化。此外，接口的实现类在初始化时也一样不会执行接口<clinit>()方法。

5. java虚拟机必须保证一个类的<clinit>()方法在多线程环境中被正确地加锁同步，如果多个线程同时去初始化一个类，那么只会有其中一个线程去执行这个类的<clinit>()方法，其他线程都需要阻塞等待，知道活动线程执行完毕<clinit>()方法
    - 需要注意，其他线程虽然会被阻塞，但如果执行<clinit>()的那条线程退出<clinit>()方法后，其他线程唤醒后则不会再次进入<clinit>()方法
    - 同一个类加载器下，一个类型只会被初始化一次
    - 如果在一个类的<clinit>()方法中有耗时很长的操作，那就可能造成多个线程阻塞，在实际应用中这种阻塞往往很隐蔽的。