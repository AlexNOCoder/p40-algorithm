# 什么是对象逃逸
### 说明
- 逃逸分析的基本原理：分析对象动态作用域，当一个对象在方法里面被定义后，它可能被外部方法所引用，例如作为调用参数传递到其他方法中，这种称为方法逃逸
- 甚至还有可能被外部线程访问到，譬如赋值给可以在其他线程中访问的实例变量，这种称为线程逃逸；从不逃逸、方法逃逸到线程逃逸，称为对象由低到高的不同逃逸程度。

优化有三种：栈上分配；标量替换；锁消除(或称同步消除)
### 栈上分配(Stack Allocations)
- 栈上分配(Stack Allocations):在java虚拟机中，java堆上分配创建对象的内存空间几乎是java程序员都知道的常识，java堆中的对象对于各个线程都是共享和可见的，只要持有这个对象的引用，就可以访问到堆中存储的对象数据。
- 虚拟机的垃圾收集子系统会回收堆中不再使用的对象，但回收动作无论是标记筛选出可回收对象，还是回收和整理内存，都需要耗费大量资源。
- 如果确定一个对象不会逃逸出线程之外，那让这个对象在栈上分配内存将是一个很不错的方法，对象所占用的内存空间就可以随栈帧出栈而销毁
- 在一般应用中，完全不会逃逸的局部对象和不会逃逸出线程的对象所占的比例是很大的，如果能使用栈上分配，那大量的对象就会随着方法的结束而自动销毁，垃圾收集子系统的压力将会下降很多，
- 栈上分配可以支持方法逃逸，但不能支持线程逃逸。

### 标量替换(Scalar Replacement)
- 若一个数据已经无法再分解成更小的数据来表示了，java虚拟机中的原始数据类型(int、long等数值类型以及reference类型等)都不能再进一步分解了，那么这些数据就可以被称为标量。
- 相对的，如果一个数据可以继续分解，那它就被称为聚合量(Aggregate),java中的对象就是典型的聚合量。
- 如果把一个java对象拆散，根据程序访问的情况，将其用到的成员变量恢复为原始访问类型来访问，这个过程就称为标量替换。
- 加入逃逸分析能够证明一个对象不会被方法外部访问，并且这个对象可以拆散，那么程序真正执行的时候将可能不去创建这个对象,而改为直接创建它的若干个被这个方法使用的成员变量来替代。
- 将对象拆分后，除了可以让对象的成员变量在栈上(栈上存储的数据，很大机会被虚拟机分配至物理机器的高速寄存器中存储)分配和读写外，还可以为后续进一步的优化手段创造条件。
- 标量替换可以视为栈上分配的一种特例，实现更简单(不用考虑整个对象完整结构的分配)，但对逃逸程度的要求更高，它不允许对象逃逸出方法范围内。

### 同步消除(Synchronization Elimination)
- 线程同步本身是一个相对耗时的过程，如果逃逸分析能够确定一个变量不会逃逸出线程，无法被其他线程访问，那么这个变量的读写肯定就不会有竞争，对这个变量实施的同步措施也就可以安全地消除掉。
