# 说说根节点枚举
### 说明

- 迄今为止，所有收集器在根节点枚举这一步时，都必须暂停用户线程的。现在可达性分析算法耗时最长的查找引用链的过程已经可以做到与用户线程一起并发，但根节点枚举始终还是必须在一个能保障一致性的快照中才能以进。
- 这里一致性的意思是整个枚举期间执行子系统看起来就像被冻结在某个时间点上，不会出现分析过程中，根节点集合的对象引用关系还在不断变化的情况，如果这点不能满足的话，分析结果准确性也就无法保证。
- 这是导致垃圾收集过程必须停顿所有用户线程的其中一个重要原因，即使是号称停顿时间可控，或者(几乎)不会发生停顿的CMS、G1、ZGC等收集器，枚举根节点时也是必须要停顿的。


- 由于目前主流java虚拟机使用的都是准确式垃圾收集，所以当用户线程停顿下来之后，其实并不需要一个不漏地检查完所有执行上下文和全局的引用位置，虚拟机是有办法直接得到哪些地方存放着对象引用的。
- 在HotSpot的解决方案里，是使用一组称为OopMap的数据结构来达到这个目的。
- 一旦类加载器动作完成的时候，HotSpot就会把对象内什么偏移量是什么类型的数据计算出来，在即时编译过程中，也会在特定的位置记录下栈里和寄存器里那些位置是引用。这样收集器在扫描时就可以直接得知这些信息了，并不需要真正一个不漏地从方法区等GC Roots开始查找。