# JVM中方法调用的两种形式
### 说明
一种形式是解析；另外一种形式是分派。

所有的方法调用的目标方法在Class文件里面都是一个常量池中的符号引用，在类加载的解析阶段，会将其中的一部分符号引用转化为直接引用，这种解析能够成立的前提是：方法在程序真正运行之前就有一个可确定的调用版本，并且这个方法的调用版本在运行期是不可变的。
换句话说，调用目标在程序代码写好、编译器进行编译那一刻就已经确定下来。这类方法的调用被称为解析(Resolution)。

调用不通过类型的方法，字节码指令集里设计了不同的指令。在java虚拟机支持以下5条方法调用字节码指令：
- invokestatic 用于调用静态方法
- invokespecial 用于调用实例构造方法<init>()方法、私有方法和父类中的方法
- invokevirtual 用于调用所有的虚方法
- invokeinterface 用于调用接口方法，会在运行时再确定一个实现该接口的对象

只要能被invokestatic和inokespecial指令调用的方法，都可以在解析阶段中确定唯一的调用版本，java语言里符合这个条件的方法共有静态方法、私有方法、实例构造器、父类方法4种，再加上被final修饰的方法(尽管它使用invokevirtual指令调用)，这5种方法调用会在类加载的时候就可以把符号引用解析为该方法的直接引用。
这些方法统称为"非虚方法"(Non-Virtual Method)，与之相反，其他方法就被称为"虚方法"(Virtual Method)。

分派又氛围静态分派，动态分派

所有依赖静态类型来决定方法执行版本的分派动作，都称为静态分派。
静态分派的最典型应用表现就是方法重载。
静态分派发生在编译阶段，因此确定静态分派的作用实际上不是由虚拟机来执行，这点也是为何一些资料选择把它归入"解析"而不是"分派"的原因

动态分派的实现过程，它与java语言多态性的另外一个重要体现--重写(Override)有很密切的关联。
动态分派其实就是动态定位到实现类的方法进行调用。