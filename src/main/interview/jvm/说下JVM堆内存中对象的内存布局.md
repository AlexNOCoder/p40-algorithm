# 说下JVM堆内存中对象的内存布局
### 说明
在HotSpot虚拟机里，对象在堆内存中的存储布局可以划分为三个部分：对象头(Header)、实例数据(InstanceData)和对齐填充(Padding)

- HotSpot虚拟机对象的对象头部分包括两类信息。第一类是用于存储对象自身的运行时数据，如哈希码(HashCode)、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等，这部分数据的长度在32位和64位的虚拟机(未开始压缩指针)中分别为32个比特和64个比特，官方称它为"Mark Word".
- 对象需要存储的运行时数据很多，其实已经超出了32、64位Bitmap结构所能记录的最大限度，但对象头里的信息是与对象自身定义的数据无关的额外存储成本，考虑到虚拟机的空间效率，Mark Word被设计成一个有着动态定义的数据结构，以便在极小的空间内存储尽量多的数据，根据对象的状态复用自己的存储空间。例如在32位的HotSpot虚拟机中，如对象未被同步锁锁定的状态下，Mark Word的32个比特存储空间中的25个比特用于存储对象哈希码，4个比特用于存储对象分代年龄，2个比特用于存储锁标志位，1个比特固定为0。对象头的另外一部分是类型指针，即对象指向它的类型元数据的指针，java虚拟机通过这个指针来确定该对象是哪个类的实例。

- 接下来实例数据部分是对象真正存储的有效信息，即我们在程序代码里面所定义的各种类型的字段内容，无论是从父类继承下来的，还是在子类中定义的字段都必须记录起来。
- 这部分的存储顺序会受到虚拟机分配策略参数(-XX: FieldAllocationStyle参数)和字段在java源码中定义顺序的影响。

- HotSpot虚拟机默认的分配顺序为longs/doubles、ints、shorts/chars、bytes/booleans、oops(Ordinary Object Pointers,OOPS)，从以上默认的分配策略中可以看到，相同宽度的字段总是被分配到一起存放，在满足这个前提条件的情况下，在父类中定义的变量会出现在子类之前。
- 如果HotSpot虚拟机+XX:CompactFields参数值为true(默认就是true)，那子类之中较窄的变量也允许插入父类变量的空隙之中，以节省出一点点空间。

- 对象的第三部分是对齐填充，这并不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用。
- 由于HotSpot虚拟机的自动内存管理系统要求对象起始地址必须是8字节的整倍数，换句话说就是任何对象的大小都必须是8字节的整数倍。对象头部已经被精心设计成正好是8字节的整数，因此，如果对象实例数据部分没有对齐的话，就需要通过对齐填充来补全。