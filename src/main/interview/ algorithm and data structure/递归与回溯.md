# 递归与回溯
### 说明

- 递归的基本性质：函数调用本身
  - 把大规模的问题不断地变小，在进行推导的过程
    
- 回溯：利用递归的性质

  - 从问题的起始点出发，不断尝试
  - 返回一步甚至多步再做选择，直到抵达终点的过程  
    

### 递归
- 递归算法是一种调用自身函数的算法
- 特点：可以使一个看似复杂的问题变得简单和易于理解
- 例子：汉诺塔
```java
void hano(char A,char B,char C,int n){
    if(n > 0){
       hano(A,C,B,n -1);
       print(A +'->' +C);
       hano(B,A,C，n-1);
        }
    }
```
- 算法思想
    - 要懂得如何将一个问题的规模变小
    - 再利用从小规模问题中得到的结果 
    - 结合当前的值或者情况，得出最终的结果
    
- 通俗理解 自顶向下
    - 要把实现的递归函数，看成已经实现好的
    - 直接利用解决一些子问题
    - 思考：如何根据子问题的解以及当前面对的情况得出答案
    
- 模板

  1. 判断当前情况是否非法，如果非法就立即返回，也称为完整性检查
  1. 判断是否满足结束递归的条件
  1. 将问题的规模缩小，递归调用
  1. 利用在小规模问题中的答案，结合当前的数据进行整合，得出最终的答案


```java
function fn(n){
        // 第一步：判断输入或者状态是否非法？
        if(input/state is invalid){
           return; 
        }
        // 第二步：判断递归是否应当结束
        if(match condition){
            return some value;
        }
        // 第三步：缩小问题规模
        result1 = fn(n1);
        result2 = fn(n2);
        
        // 第四步：整合规则
        return combine(result1,result2);
    
        }
```

### 递归
- 回溯算法是一种试探算法，与暴力搜索的最大区别：
  - 在回溯算法中，是一步步向前试探，对每一步探测的情况评估，再决定是否继续，可避免走弯路

- 回溯算法的精华
  - 出现非法的情况时，可退到之前的情景，可返回一步或多步
  - 再去尝试别的路径和办法
  
- 想要采用回溯算法，就必须保证：每次都有多种尝试的可能

- 模板
  1. 首先判断当前情况是否非法，如果非法立即返回
  1. 看看当前情况是否已经满足条件，如果是，就将当前结果保存起来并返回
  1. 在当前情况下，遍历所有可能出现的情况，并进行递归
  1. 递归完毕后，立即回溯，回溯的方法就是取消前一步的尝试

- 回溯是基于递归的，时间复杂度的计算和递归相同 
```java
   function fn(){
    // 第一步：判断输入或者状态是否非法
    if(input/state is invalid){
        return ;
        }
    // 第二步：判断递归是否应当结束    
    if(match condition){
        return some value;
        }
    // 遍历所有可能出现的情况
    for(all possible cases){
       // 第三步：尝试下一步的可能性
        solution.push(case)
        // 递归
        result = fn(m)
        // 第四步：回溯到上一步
        solution.pop(case)
        }
  }


```
