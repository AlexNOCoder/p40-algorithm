# Spring是如何解决Bean的循环依赖的

### 说明
Spring是如何解决循环依赖的：使用三级缓存，三个Map；关键：一定要有一个缓存保存它的早期对象作为死循环的出口
- 一级缓存：存储完整的Bean
- 二级缓存：避免多重循环依赖情况 重复创建动态代理
- 三级缓存：
   - 函数接口 lambda 把方法传进去(把Bean的实力和Bean名字传进去) aop创建
   - 不会立即调用（如果在实例化后立即调用的话，所有的aop 不管bean是否循环依赖了，都会在实例化后创建动态代理proxy，正常的bean 其实spring还是希望遵循生命周期在初始化创建动态代理，只能循环依赖才创建）
   - 会在ABA(第二次getBean(A) 才会去调用三级缓存(如何实现了aop创建动态代理，如果没有实现依然返回的Bean的实例))
   - 放入二级缓存(避免重复创建)
    
### 流程
1. getBean(A)
1. doGetBean(A)
1. getSingleton(A,boolean) （从一级缓存中获取并返回）
1. getSingleton(A,objectFactory)
1. createBean(A,boolean)
1. doCreateBean(A....)
1. 实例化 （加入三级缓存）
1. 加入三级缓存
1. 属性赋值(可能导致循环依赖)
1. 初始化
1. getSingleton() add一级缓存 remove 二三级缓存

### 其他问题
1.二级缓存能不能解决循环依赖？
 - 如果只是解决死循环问题：一级缓存就可以解决，无法避免在并发情况下获取到不完整bean的问题
 - 二级缓存也可以解决循环依赖：只不过如果重复循环依赖，会多次创建动态代理
 - 可以不放入lambda表达式，而是创建aop，后直接放入二级缓存

2.Spring有没有解决多例Bean的循环依赖？（scope = prototype）
 - 多例不会使用缓存进行存储(多例bean每次使用都需要重新创建)
 - 不缓存早期对象就无法解决循环依赖

3.Spring有没有解决构造函数参数Bean的循环依赖？
 - 构造函数的循环依赖也是会报错的
 - 通过人工加@Lazy解决
   1. 不会立即创建依赖的bean了
   1. 而是等到用到的时候才通过动态代理进行创建
   1. 调用 --ioc.get(A)-> A实例 --a.getB()->获得B代理 --a.getB().xxx()->B代理.interept()---->ioc.get(B).xxx()此时就调用beanB的方法
