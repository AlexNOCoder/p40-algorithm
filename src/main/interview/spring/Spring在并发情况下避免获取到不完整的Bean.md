# Spring在并发情况下避免获取到不完整的Bean

### 说明
- 双重检查锁 2个同步锁 2次检查一级缓存
- 两个线程A和B，A先到，如果A在一级缓存中没有拿到，它会锁住直到创建好并放入一级缓存，并移除二三级缓存，然后释放锁。
B这个时候拿到锁以后并不能拿到一级缓存中创建好的bean，后面再创建前还会去一级缓存中获取一次，这样就能拿到线程A创建的bean了。


### 为什么一级缓存不加锁
由于性能，避免已经创建好的bean阻塞等待