# JDK动态代理和CGLIB动态代理的区别
### 说明

- Spring AOP中的动态代理主要有两种方式，JDK动态代理和CGLIB动态代理：
- JDK动态代理只提供接口的代理，不支持类的代理
  1. JDK会在运行时为目标类生成一个 动态代理类 $proxy*.class
  1. 该代理类是实现了目标类接口的一个类，并且代理类会实现接口所有的方法的增强代码
  1. 调用时通过代理类先去调用处理类进行增强，再通过反射的方式进行调用目标方法，从而实现AOP
- 如果代理类没有实现接口，那么Spring AOP会选择使用CGLIB来动态代理目标类
  1. CGLIB的底层是通过ASM开源字节码生成库在运行时动态的生产目标类的一个子类。（还有其他相关类，主要是为了增强调用时效率）会生成多个
  1. 并且会重写父类所有的方法增强代码 
  1. 调用时先通过代理类进行增强，再直接调用父类对应的方法进行调用目标方法。从而实现AOP。
     - CGLIB是通过继承的方式做的动态代理，因此如果某个类被标记为final，那么它是无法使用CGLIB做动态代理的
     - CGLIB除了生成目标子类代理类，还有一个FastClass(路由类),可以(但不是必须)让本类方法调用进行增强，而不会像jdk代理那样本类方法调用增强会失效。
- 对比JDK和CGLIB的性能
  1. jdk动态代理生成类速度快，调用慢 
     
  1. CGLIB生成类速度慢，但后续调用快
     
  1. 在老版本CGLIB的速度是JDK速度的10倍左右
     
  1. 但是实际上JDK的速度在版本升级的时候每次都提高很多性能，而CGLIB仍停滞不前。
     
  1. 在对JDK动态代理与CGLIB动态代理的代码实验中看，1W次执行下，JDK7以及8的动态代理性能比CGLIB要好20%左右。