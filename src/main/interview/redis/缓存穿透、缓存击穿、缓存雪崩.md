# 缓存穿透、缓存击穿、缓存雪崩

### 缓存穿透
- 缓存和数据库中都没有的数据，导致所有的请求都落到数据库上，造成数据库短时间内承受大量请求而崩掉
- 解决方案：
  1. 接口层增加校验，对参数进行合法性校验
  2. 将数据库中没有查到结果的数据也写入到缓存。这时候要注意防止Redis被无用的Key占满，这一类缓存的有效期要设得短一些
  3. 引入布隆过滤器,在访问Redis之前判断数据是否存在，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap过滤拦截掉，从而避免了对底层存储系统的查询压力。

### 缓存击穿
- 缓存中没有，数据库中有。一般是出现在存数数据初始化以及key过期了的情况。他的问题在于，重新写入缓存需要一定的时间，如果是在高并发场景下，过多的请求就会瞬间写到DB上，给DB造成很大的压力
- 解决方案：
  - 1. 设置这个热点缓存永不过期。这是要注意在value当中包含一个逻辑上的过期时间，然后另起一个线程，定期重建这些缓存
  - 2. 加互斥锁

### 缓存雪崩
- 缓存同一时间大面积的失效，所以，后面的请求都会落到数据库上，造成数据库段时间内承受大量请求而崩掉。
- 解决方案：
  1. 把缓存的失效时间分散开，例如，在原有的统一失效时间基础上，增加一个随机值
  2. 对热点数据设置永不过期，和缓存策略中一样。
  3. 缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生
  4. 给每一个缓存数据增加相应的缓存标记，记录缓存是否失效，如果缓存标记失效，则更新数据缓存
  5. 缓存预热
  6. 互斥锁