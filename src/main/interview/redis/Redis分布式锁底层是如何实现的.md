# Redis分布式锁底层是如何实现的
### 说明

1. 首先利用setnx来保证：如果key不存在才能获取到锁，如果key存在，则获取不到锁
1. 然后还要利用lua脚本来保证多个redis操作的原子性
1. 同时还要考虑锁过期，所以需要额外的一个看门狗定时任务来监听锁是否需要续约
1. 同时还要考虑到redis节点挂掉后的情况，所以需要采用红锁的方式同时向N/2+1个节点申请锁，都申请到了才证明获取锁成功，这样就算其中某个redis节点挂掉了，锁也不会被其他客户获取到

setnx+setex:存在设置超时时间失败的情况，导致死锁
set(key,value,nx,px):将setnx+setex变成原子操作

### 问题

- 任务超时，锁自动释放，导致编发问题。使用redision解决(看门狗监听，自动续期)
- 以及加锁和释放锁不是同一个线程问题。在value中存入uuid(线程唯一标识)，删除锁时判断该标识(使用lua保证原子操作)
- 不可重入，使用redission解决(实现机制类似AQS，计数)
- 异步复制可能造成锁丢失，使用redlock解决
  1. 顺序向五个节点请求加锁
  1. 根据一定的超时时间来判断是不是跳过该节点
  1. 三个节点加锁成果并且花费时间小于锁的有效期
  1. 认定加锁成功