# 说说Seata的实现原理
### 说明

- 在应用中Seata整体事务逻辑基于两段提交的模型，核心概念包含三个角色：
- TC：事务协调者，即独立运行的seata-server，用于接收事务注册，提交和回滚
- TM：事务发起者，用来告诉TC全局事务的开始，提交，回滚
- RM：事务资源，每一个RM都会作为一个分支事务注册在TC

### AT(Auto Transaction)模式
- 第一阶段

  - 过程:
    1. TM向TC申请开启一个全局事务，全局事务创建并生成一个全局唯一的XID
    1. XID在微服务调用链的上下文中传播
    1. 假设运行：update product set name = 'GTS' where name = 'TSC'；//id = 1
    1. 解析sql：得到sql的类型(UPDATE)，表(product),条件(where name = 'TXC')等相关信息
    1. 查询前镜像：根据解析得到的条件查询，生成查询语句，定位数据。select * from product where name ='TXC' 镜像前数据
    1. 查询业务SQL：更新这条记录的name为'GTS'
    1. 查询后镜像：根据前镜像的结果，通过主键定位数据。select * from product where name ='TXC'  镜像后数据
    1. 插入回滚日志：把前后镜像数据以及业务sql相关的信息组成一条回滚日志记录，插入到UNDO_LOG表中

    1. 提交前，RM向TC注册分支：申请product表中，主键值等于1的记录的全局锁
    1. 本地事务提交：业务数据局的更新和前面步骤中生成的UNDO LOG一并提交
    1. TM向TC发起针对XID的全局提交或回滚决议。将本地事务提交的结果上报给TC

- 二阶段-提交
  - TC调度XID下管辖的全部分支事务完成提交或回滚请求
    1. 收到TC的分支提交请求，把请求放入一个异步任务的队列中，马上返回提交成功的结果给TC。
    1. 异步任务阶段的分支：提交请求，将异步和批量地删除相应UNDO LOG记录

- 二阶段-回滚
   - TC调度XID下管辖的全部分支事务完成提交或回滚请求

     1. 收到TC的分支回滚请求，开启一个本地事务，执行如下操作
     1. 通过XID和Branch ID查找到相应的UNDO LOG记录
     1. 数据校验：拿UNDO LOG中的后镜像与当前数据进行比较，如果有不同，说明数据被当前全局事务之外的动作做了修改(出现脏写),转人工处理(因为Seata无法感知这个脏写如何发生，此时只能打印日志和触发异常通知，告知用户需要人工介入)
     1. 人工没有脏写就简单了：根据UNDO LOG中前镜像和业务SQL的相关信息生成并执行回滚的语句
     1. 提交本地事务，并把本地事务的执行结果(即分支事务回滚的结果)上报个TC